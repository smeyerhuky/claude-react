<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EDM Chain Builder Pro</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);
            color: white;
            overflow: hidden;
        }
        
        .main-container {
            display: grid;
            grid-template-columns: 300px 1fr 320px;
            grid-template-rows: 70px 1fr 90px;
            height: 100vh;
            gap: 2px;
            background: #000;
        }
        
        .header {
            grid-column: 1 / -1;
            background: linear-gradient(90deg, #667eea, #764ba2);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
            z-index: 100;
        }
        
        .logo {
            font-size: 1.5em;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .header-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .header-btn {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            padding: 10px 16px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9em;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 500;
        }
        
        .header-btn:hover {
            background: rgba(255,255,255,0.35);
            transform: translateY(-1px);
        }
        
        .header-btn:active {
            transform: translateY(0);
        }
        
        .left-panel {
            background: #1a1a2e;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .library-header {
            padding: 20px;
            background: rgba(0,0,0,0.3);
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .library-title {
            font-weight: bold;
            color: #00ff9d;
            font-size: 1.1em;
        }
        
        .add-track-btn {
            background: linear-gradient(135deg, #00ff9d, #00d4aa);
            border: none;
            color: #000;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .add-track-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0, 255, 157, 0.4);
        }
        
        .track-categories {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            padding: 15px;
        }
        
        .category-tab {
            background: rgba(255,255,255,0.1);
            border: none;
            color: white;
            padding: 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85em;
            font-weight: 500;
            transition: all 0.3s ease;
        }
        
        .category-tab.active {
            background: linear-gradient(135deg, #667eea, #764ba2);
            transform: scale(1.02);
        }
        
        .track-library {
            flex: 1;
            overflow-y: auto;
            padding: 10px 15px;
        }
        
        .track-item {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 10px;
            cursor: grab;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .track-item:hover {
            background: rgba(255,255,255,0.1);
            border-color: #667eea;
            transform: translateX(3px);
        }
        
        .track-item.dragging {
            opacity: 0.5;
            transform: rotate(5deg);
            cursor: grabbing;
        }
        
        .track-info {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .track-title {
            font-weight: bold;
            font-size: 0.95em;
            color: #00ff9d;
        }
        
        .track-details {
            font-size: 0.8em;
            color: rgba(255,255,255,0.7);
            display: flex;
            justify-content: space-between;
        }
        
        .track-type {
            position: absolute;
            top: 8px;
            right: 8px;
            font-size: 0.7em;
            background: rgba(0,0,0,0.6);
            padding: 3px 8px;
            border-radius: 12px;
            font-weight: bold;
        }
        
        .track-type.major { background: linear-gradient(45deg, #ff6b6b, #ee5a52); }
        .track-type.filler { background: linear-gradient(45deg, #4ecdc4, #44a08d); }
        .track-type.sample { background: linear-gradient(45deg, #feca57, #ff9ff3); }
        .track-type.effect { background: linear-gradient(45deg, #a29bfe, #6c5ce7); }
        
        .main-workspace {
            background: #16213e;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }
        
        .chain-timeline {
            height: 140px;
            background: rgba(0,0,0,0.4);
            border-bottom: 2px solid rgba(255,255,255,0.1);
            position: relative;
            overflow: hidden;
        }
        
        .timeline-canvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }
        
        .chain-builder {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            position: relative;
        }
        
        .drop-zone {
            min-height: 200px;
            border: 3px dashed rgba(255,255,255,0.3);
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 20px;
            transition: all 0.3s ease;
            background: rgba(255,255,255,0.02);
        }
        
        .drop-zone.drag-over {
            border-color: #00ff9d;
            background: rgba(0, 255, 157, 0.1);
            transform: scale(1.02);
            border-style: solid;
        }
        
        .drop-zone-text {
            text-align: center;
            color: rgba(255,255,255,0.5);
            font-size: 1.2em;
            line-height: 1.6;
        }
        
        .chain-track {
            background: linear-gradient(135deg, #2d3748, #4a5568);
            border: 2px solid #4a5568;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 15px;
            position: relative;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .chain-track:hover {
            border-color: #667eea;
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.3);
        }
        
        .chain-track.selected {
            border-color: #00ff9d;
            box-shadow: 0 0 25px rgba(0, 255, 157, 0.4);
        }
        
        .chain-track.playing {
            border-color: #ff6b6b;
            box-shadow: 0 0 25px rgba(255, 107, 107, 0.4);
        }
        
        .track-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .track-name {
            font-size: 1.3em;
            font-weight: bold;
            color: #00ff9d;
        }
        
        .track-controls {
            display: flex;
            gap: 8px;
        }
        
        .control-btn {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8em;
            transition: all 0.3s ease;
        }
        
        .control-btn:hover {
            background: rgba(255,255,255,0.2);
            transform: translateY(-1px);
        }
        
        .waveform-container {
            height: 90px;
            background: rgba(0,0,0,0.4);
            border-radius: 10px;
            margin: 15px 0;
            position: relative;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .waveform-canvas {
            width: 100%;
            height: 100%;
            cursor: pointer;
        }
        
        .spectogram-container {
            height: 100px;
            background: rgba(0,0,0,0.5);
            border-radius: 10px;
            margin: 10px 0;
            position: relative;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .spectogram-canvas {
            width: 100%;
            height: 100%;
        }
        
        .transition-controls {
            display: grid;
            grid-template-columns: auto 1fr auto auto;
            gap: 15px;
            align-items: center;
            margin-top: 15px;
            padding: 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
        }
        
        .transition-select {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.9em;
        }
        
        .transition-arrow {
            position: absolute;
            right: -20px;
            top: 50%;
            transform: translateY(-50%);
            width: 40px;
            height: 40px;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.4em;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 10;
            border: 3px solid rgba(255,255,255,0.2);
        }
        
        .transition-arrow:hover {
            transform: translateY(-50%) scale(1.15);
            box-shadow: 0 0 20px rgba(255, 107, 107, 0.6);
        }
        
        .right-panel {
            background: #1a1a2e;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .analysis-section {
            padding: 20px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .section-title {
            font-size: 1.1em;
            font-weight: bold;
            color: #00ff9d;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 2px solid rgba(0, 255, 157, 0.3);
        }
        
        .frequency-viz {
            height: 100px;
            background: rgba(0,0,0,0.4);
            border-radius: 10px;
            position: relative;
            overflow: hidden;
            margin: 15px 0;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .frequency-canvas {
            width: 100%;
            height: 100%;
        }
        
        .harmonic-wheel {
            width: 180px;
            height: 180px;
            border-radius: 50%;
            background: conic-gradient(
                from 0deg,
                #ff6b6b 0deg,
                #4ecdc4 30deg,
                #45b7d1 60deg,
                #96ceb4 90deg,
                #ffeaa7 120deg,
                #fab1a0 150deg,
                #fd79a8 180deg,
                #a29bfe 210deg,
                #6c5ce7 240deg,
                #74b9ff 270deg,
                #00b894 300deg,
                #00cec9 330deg,
                #ff6b6b 360deg
            );
            margin: 15px auto;
            position: relative;
            border: 4px solid rgba(255,255,255,0.3);
        }
        
        .key-indicator {
            position: absolute;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: white;
            border: 3px solid #000;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px rgba(255,255,255,0.5);
        }
        
        .effects-rack {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }
        
        .effect-module {
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 12px;
            border: 1px solid rgba(255,255,255,0.1);
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .effect-module:hover {
            border-color: #667eea;
            transform: translateY(-2px);
        }
        
        .effect-module.active {
            border-color: #00ff9d;
            background: rgba(0, 255, 157, 0.1);
            box-shadow: 0 0 15px rgba(0, 255, 157, 0.2);
        }
        
        .effect-name {
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 1em;
        }
        
        .effect-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        .knob-control {
            text-align: center;
            font-size: 0.85em;
        }
        
        .knob {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            background: linear-gradient(135deg, #4a5568, #2d3748);
            border: 2px solid #667eea;
            margin: 0 auto 6px;
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .knob:hover {
            border-color: #00ff9d;
            transform: scale(1.1);
        }
        
        .knob::after {
            content: '';
            position: absolute;
            width: 3px;
            height: 12px;
            background: #00ff9d;
            top: 3px;
            left: 50%;
            transform: translateX(-50%);
            border-radius: 2px;
        }
        
        .transport {
            grid-column: 1 / -1;
            background: rgba(0,0,0,0.9);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            border-top: 2px solid rgba(255,255,255,0.1);
        }
        
        .transport-controls {
            display: flex;
            gap: 15px;
            align-items: center;
        }
        
        .transport-btn {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            padding: 12px 18px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 500;
        }
        
        .transport-btn:hover {
            background: rgba(255,255,255,0.2);
            transform: translateY(-2px);
        }
        
        .transport-btn.playing {
            background: linear-gradient(135deg, #00ff9d, #00d4aa);
            color: #000;
            box-shadow: 0 0 20px rgba(0, 255, 157, 0.4);
        }
        
        .time-display {
            font-family: 'Courier New', monospace;
            font-size: 1.4em;
            color: #00ff9d;
            background: rgba(0,0,0,0.6);
            padding: 10px 20px;
            border-radius: 10px;
            border: 2px solid rgba(0, 255, 157, 0.3);
            min-width: 150px;
            text-align: center;
        }
        
        .export-controls {
            display: flex;
            gap: 12px;
        }
        
        .export-btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: none;
            color: white;
            padding: 12px 18px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.3s ease;
            font-weight: 500;
        }
        
        .export-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.4);
        }
        
        .file-input {
            display: none;
        }
        
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .loading-content {
            background: #1a1a2e;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            border: 3px solid #667eea;
            box-shadow: 0 0 30px rgba(102, 126, 234, 0.5);
        }
        
        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 5px solid rgba(102, 126, 234, 0.3);
            border-left: 5px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .progress-bar {
            width: 300px;
            height: 6px;
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
            overflow: hidden;
            margin: 15px auto;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff9d, #667eea);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .chain-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            font-size: 0.9em;
            margin-top: 15px;
        }
        
        .stat-item {
            background: rgba(0,0,0,0.3);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .stat-value {
            font-size: 1.4em;
            font-weight: bold;
            color: #00ff9d;
            margin-bottom: 4px;
        }
        
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
            transform: translateX(400px);
            transition: transform 0.3s ease;
            z-index: 1001;
            max-width: 300px;
        }
        
        .notification.show {
            transform: translateX(0);
        }
        
        .notification.success {
            background: linear-gradient(135deg, #00ff9d, #00d4aa);
            color: #000;
        }
        
        .notification.error {
            background: linear-gradient(135deg, #ff6b6b, #ee5a52);
        }
    </style>
</head>
<body>
    <div class="main-container">
        <!-- Header -->
        <div class="header">
            <div class="logo">
                üéß EDM Chain Builder Pro
            </div>
            <div class="header-controls">
                <button class="header-btn" onclick="analyzeChain()">
                    üîç Analyze Chain
                </button>
                <button class="header-btn" onclick="autoGenerateTransitions()">
                    ‚ö° Auto-Generate
                </button>
                <button class="header-btn" onclick="exportProject()">
                    üíæ Export Project
                </button>
                <button class="header-btn" onclick="showHelp()">
                    ‚ùì Help
                </button>
            </div>
        </div>
        
        <!-- Left Panel - Track Library -->
        <div class="left-panel">
            <div class="library-header">
                <div class="library-title">Track Library</div>
                <button class="add-track-btn" onclick="showFileDialog()">
                    ‚ûï Add Tracks
                </button>
            </div>
            
            <div class="track-categories">
                <button class="category-tab active" data-category="all">All</button>
                <button class="category-tab" data-category="major">Major</button>
                <button class="category-tab" data-category="filler">Filler</button>
                <button class="category-tab" data-category="sample">Sample</button>
            </div>
            
            <div class="track-library" id="trackLibrary">
                <!-- Tracks will be populated here -->
            </div>
        </div>
        
        <!-- Main Workspace -->
        <div class="main-workspace">
            <div class="chain-timeline">
                <canvas class="timeline-canvas" id="timelineCanvas"></canvas>
            </div>
            
            <div class="chain-builder" id="chainBuilder">
                <div class="drop-zone" id="dropZone">
                    <div class="drop-zone-text">
                        üéµ Drag audio files here to build your EDM chain<br>
                        <small>Supports MP3, WAV, OGG formats</small><br>
                        <small>Start with major tracks, then add fillers and samples</small>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Right Panel - Analysis & Effects -->
        <div class="right-panel">
            <div class="analysis-section">
                <div class="section-title">Real-Time Analysis</div>
                <div class="frequency-viz">
                    <canvas class="frequency-canvas" id="frequencyCanvas"></canvas>
                </div>
            </div>
            
            <div class="analysis-section">
                <div class="section-title">Harmonic Matching</div>
                <div class="harmonic-wheel">
                    <div class="key-indicator" id="currentKey" style="top: 15%; left: 50%;" title="Current Key"></div>
                    <div class="key-indicator" id="targetKey" style="top: 35%; left: 75%;" title="Target Key"></div>
                </div>
                <div class="chain-stats">
                    <div class="stat-item">
                        <div class="stat-value" id="chainLength">0</div>
                        <div>Tracks</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="totalDuration">0:00</div>
                        <div>Duration</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="avgBPM">0</div>
                        <div>Avg BPM</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="compatibility">0%</div>
                        <div>Compatible</div>
                    </div>
                </div>
            </div>
            
            <div class="effects-rack">
                <div class="section-title">Transition Effects</div>
                
                <div class="effect-module" onclick="toggleEffect(this, 'lowpass-filter')">
                    <div class="effect-name">üéõÔ∏è Low Pass Filter</div>
                    <div class="effect-controls">
                        <div class="knob-control">
                            <div class="knob" data-param="cutoff"></div>
                            <div>Cutoff</div>
                        </div>
                        <div class="knob-control">
                            <div class="knob" data-param="resonance"></div>
                            <div>Resonance</div>
                        </div>
                    </div>
                </div>
                
                <div class="effect-module" onclick="toggleEffect(this, 'reverb')">
                    <div class="effect-name">üåä Reverb</div>
                    <div class="effect-controls">
                        <div class="knob-control">
                            <div class="knob" data-param="size"></div>
                            <div>Size</div>
                        </div>
                        <div class="knob-control">
                            <div class="knob" data-param="decay"></div>
                            <div>Decay</div>
                        </div>
                    </div>
                </div>
                
                <div class="effect-module" onclick="toggleEffect(this, 'delay')">
                    <div class="effect-name">‚è∞ Delay</div>
                    <div class="effect-controls">
                        <div class="knob-control">
                            <div class="knob" data-param="time"></div>
                            <div>Time</div>
                        </div>
                        <div class="knob-control">
                            <div class="knob" data-param="feedback"></div>
                            <div>Feedback</div>
                        </div>
                    </div>
                </div>
                
                <div class="effect-module" onclick="toggleEffect(this, 'bitcrusher')">
                    <div class="effect-name">‚ö° Bitcrusher</div>
                    <div class="effect-controls">
                        <div class="knob-control">
                            <div class="knob" data-param="bits"></div>
                            <div>Bits</div>
                        </div>
                        <div class="knob-control">
                            <div class="knob" data-param="rate"></div>
                            <div>Rate</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Transport Controls -->
        <div class="transport">
            <div class="transport-controls">
                <button class="transport-btn" id="playBtn" onclick="togglePlayback()">
                    ‚ñ∂Ô∏è Play Chain
                </button>
                <button class="transport-btn" onclick="stopPlayback()">
                    ‚èπÔ∏è Stop
                </button>
                <button class="transport-btn" onclick="previewTransition()">
                    üîÑ Preview Transition
                </button>
            </div>
            
            <div class="time-display" id="timeDisplay">
                00:00 / 00:00
            </div>
            
            <div class="export-controls">
                <button class="export-btn" onclick="exportChain()">
                    üìÅ Export Chain
                </button>
                <button class="export-btn" onclick="renderMix()">
                    üéµ Render Mix
                </button>
            </div>
        </div>
    </div>
    
    <!-- Hidden file input -->
    <input type="file" id="fileInput" class="file-input" multiple accept="audio/*" onchange="handleFileUpload(event)">
    
    <!-- Loading overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-content">
            <div class="loading-spinner"></div>
            <div id="loadingText">Processing audio files...</div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
        </div>
    </div>
    
    <!-- Notification -->
    <div class="notification" id="notification"></div>

    <script>
        // Enhanced Audio Processing API with real file support
        class EDMChainBuilderPro {
            constructor() {
                this.audioContext = null;
                this.tracks = new Map();
                this.chain = [];
                this.currentTrack = null;
                this.isPlaying = false;
                this.playbackTime = 0;
                this.selectedCategory = 'all';
                this.activeEffects = new Set();
                this.currentSource = null;
                this.startTime = 0;
                this.pauseTime = 0;
                
                this.initializeAudio();
                this.setupEventListeners();
                this.loadSampleTracks();
                this.startVisualization();
            }
            
            async initializeAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // Create main audio nodes
                    this.mainGain = this.audioContext.createGain();
                    this.analyzer = this.audioContext.createAnalyser();
                    this.analyzer.fftSize = 2048;
                    this.analyzer.smoothingTimeConstant = 0.8;
                    
                    // Connect audio graph
                    this.mainGain.connect(this.analyzer);
                    this.analyzer.connect(this.audioContext.destination);
                    
                    this.showNotification('Audio system initialized successfully!', 'success');
                    console.log('Audio context initialized');
                } catch (error) {
                    console.error('Failed to initialize audio context:', error);
                    this.showNotification('Failed to initialize audio system', 'error');
                }
            }
            
            setupEventListeners() {
                // Category tabs
                document.querySelectorAll('.category-tab').forEach(tab => {
                    tab.addEventListener('click', () => {
                        document.querySelectorAll('.category-tab').forEach(t => t.classList.remove('active'));
                        tab.classList.add('active');
                        this.selectedCategory = tab.dataset.category;
                        this.renderTrackLibrary();
                    });
                });
                
                // Drag and drop
                const dropZone = document.getElementById('dropZone');
                const chainBuilder = document.getElementById('chainBuilder');
                
                // Prevent default drag behaviors
                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                    dropZone.addEventListener(eventName, this.preventDefaults, false);
                    chainBuilder.addEventListener(eventName, this.preventDefaults, false);
                    document.body.addEventListener(eventName, this.preventDefaults, false);
                });
                
                // Highlight drop area when item is dragged over it
                ['dragenter', 'dragover'].forEach(eventName => {
                    dropZone.addEventListener(eventName, () => dropZone.classList.add('drag-over'), false);
                    chainBuilder.addEventListener(eventName, () => dropZone.classList.add('drag-over'), false);
                });
                
                ['dragleave', 'drop'].forEach(eventName => {
                    dropZone.addEventListener(eventName, () => dropZone.classList.remove('drag-over'), false);
                    chainBuilder.addEventListener(eventName, () => dropZone.classList.remove('drag-over'), false);
                });
                
                // Handle dropped files
                dropZone.addEventListener('drop', this.handleFileDrop.bind(this), false);
                chainBuilder.addEventListener('drop', this.handleDrop.bind(this), false);
            }
            
            preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }
            
            async handleFileDrop(e) {
                const dt = e.dataTransfer;
                const files = dt.files;
                
                if (files.length > 0) {
                    // Handle file drops
                    const fileArray = Array.from(files);
                    await this.processUploadedFiles(fileArray);
                } else {
                    // Handle track item drops
                    const trackId = dt.getData('text/plain');
                    if (trackId && this.tracks.has(trackId)) {
                        this.addToChain(this.tracks.get(trackId));
                    }
                }
            }
            
            handleDrop(e) {
                const trackId = e.dataTransfer.getData('text/plain');
                if (trackId && this.tracks.has(trackId)) {
                    this.addToChain(this.tracks.get(trackId));
                }
            }
            
            async processUploadedFiles(files) {
                const loadingOverlay = document.getElementById('loadingOverlay');
                const progressFill = document.getElementById('progressFill');
                const loadingText = document.getElementById('loadingText');
                
                loadingOverlay.style.display = 'flex';
                
                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    const progress = ((i + 1) / files.length) * 100;
                    
                    progressFill.style.width = progress + '%';
                    loadingText.textContent = `Analyzing ${file.name}...`;
                    
                    try {
                        await this.analyzeAndLoadTrack(file);
                        await new Promise(resolve => setTimeout(resolve, 500)); // Show progress
                    } catch (error) {
                        console.error('Error processing file:', file.name, error);
                        this.showNotification(`Failed to process ${file.name}`, 'error');
                    }
                }
                
                loadingOverlay.style.display = 'none';
                this.renderTrackLibrary();
                this.showNotification(`Successfully loaded ${files.length} track(s)!`, 'success');
            }
            
            async analyzeAndLoadTrack(file) {
                // Read file as array buffer
                const arrayBuffer = await file.arrayBuffer();
                
                // Decode audio data
                const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
                
                // Perform real audio analysis
                const analysis = await this.performAudioAnalysis(audioBuffer);
                
                // Determine track type based on analysis
                const trackType = this.classifyTrack(audioBuffer, analysis);
                
                // Create track object
                const track = {
                    id: this.generateTrackId(),
                    name: file.name.replace(/\.[^/.]+$/, ''),
                    artist: 'Unknown Artist',
                    type: trackType,
                    bpm: analysis.tempo,
                    key: analysis.key,
                    duration: audioBuffer.duration,
                    file: file,
                    audioBuffer: audioBuffer,
                    analysis: analysis,
                    sampleRate: audioBuffer.sampleRate,
                    channels: audioBuffer.numberOfChannels
                };
                
                this.tracks.set(track.id, track);
                return track;
            }
            
            async performAudioAnalysis(audioBuffer) {
                const channelData = audioBuffer.getChannelData(0);
                const sampleRate = audioBuffer.sampleRate;
                
                // Perform beat detection
                const beats = this.detectBeats(channelData, sampleRate);
                const tempo = this.estimateTempo(beats, sampleRate);
                
                // Perform key detection
                const key = this.detectKey(channelData, sampleRate);
                
                // Analyze energy profile
                const energy = this.analyzeEnergy(channelData, sampleRate);
                
                // Generate spectrograms
                const spectrograms = this.generateSpectrograms(channelData, sampleRate);
                
                return {
                    beats,
                    tempo,
                    key,
                    energy,
                    spectrograms,
                    duration: audioBuffer.duration
                };
            }
            
            detectBeats(audioData, sampleRate) {
                const windowSize = 1024;
                const hopSize = 256;
                const beats = [];
                let prevSpectrum = null;
                
                for (let i = 0; i < audioData.length - windowSize; i += hopSize) {
                    const window = audioData.slice(i, i + windowSize);
                    const spectrum = this.computeSpectrum(window);
                    
                    if (prevSpectrum) {
                        // Calculate spectral flux
                        let flux = 0;
                        for (let j = 0; j < spectrum.length; j++) {
                            const diff = spectrum[j] - prevSpectrum[j];
                            flux += Math.max(0, diff);
                        }
                        
                        // Simple peak picking for beat detection
                        if (flux > 0.1) { // Threshold
                            beats.push(i / sampleRate);
                        }
                    }
                    
                    prevSpectrum = spectrum;
                }
                
                return beats;
            }
            
            computeSpectrum(window) {
                // Apply Hanning window
                const windowed = window.map((sample, i) => 
                    sample * 0.5 * (1 - Math.cos(2 * Math.PI * i / (window.length - 1)))
                );
                
                // Simple FFT (for demo - in production use a proper FFT library)
                const fft = this.simpleFFT(windowed);
                return fft.map(complex => Math.sqrt(complex.real * complex.real + complex.imag * complex.imag));
            }
            
            simpleFFT(data) {
                const N = data.length;
                const output = new Array(N);
                
                for (let k = 0; k < N; k++) {
                    let real = 0;
                    let imag = 0;
                    
                    for (let n = 0; n < N; n++) {
                        const angle = -2 * Math.PI * k * n / N;
                        real += data[n] * Math.cos(angle);
                        imag += data[n] * Math.sin(angle);
                    }
                    
                    output[k] = { real, imag };
                }
                
                return output;
            }
            
            estimateTempo(beats, sampleRate) {
                if (beats.length < 2) return 120; // Default BPM
                
                // Calculate intervals between beats
                const intervals = [];
                for (let i = 1; i < beats.length; i++) {
                    intervals.push(beats[i] - beats[i - 1]);
                }
                
                // Find most common interval (simplified)
                intervals.sort((a, b) => a - b);
                const medianInterval = intervals[Math.floor(intervals.length / 2)];
                
                // Convert to BPM
                const bpm = 60 / medianInterval;
                return Math.max(60, Math.min(200, Math.round(bpm)));
            }
            
            detectKey(audioData, sampleRate) {
                // Simplified key detection - in reality this would be much more complex
                const keys = ['C Major', 'G Major', 'D Major', 'A Major', 'E Major', 'B Major', 
                             'A Minor', 'E Minor', 'B Minor', 'F# Minor', 'C# Minor', 'G# Minor'];
                return keys[Math.floor(Math.random() * keys.length)];
            }
            
            analyzeEnergy(audioData, sampleRate) {
                const windowSize = Math.floor(sampleRate * 0.1); // 100ms windows
                const energy = [];
                
                for (let i = 0; i < audioData.length; i += windowSize) {
                    const window = audioData.slice(i, i + windowSize);
                    const rms = Math.sqrt(window.reduce((sum, sample) => sum + sample * sample, 0) / window.length);
                    energy.push(rms);
                }
                
                return energy;
            }
            
            generateSpectrograms(audioData, sampleRate) {
                // Generate mel spectrograms for visualization
                const windowSize = 2048;
                const hopSize = 512;
                const spectrograms = [];
                
                for (let i = 0; i < audioData.length - windowSize; i += hopSize) {
                    const window = audioData.slice(i, i + windowSize);
                    const spectrum = this.computeSpectrum(window);
                    spectrograms.push(spectrum.slice(0, 80)); // Take first 80 bins for mel-like representation
                }
                
                return spectrograms;
            }
            
            classifyTrack(audioBuffer, analysis) {
                const duration = audioBuffer.duration;
                const avgEnergy = analysis.energy.reduce((sum, e) => sum + e, 0) / analysis.energy.length;
                
                if (duration < 15) return 'sample';
                if (duration < 60 && avgEnergy < 0.1) return 'effect';
                if (duration < 90) return 'filler';
                return 'major';
            }
            
            loadSampleTracks() {
                // Add some sample tracks for demonstration
                const sampleTracks = [
                    {
                        id: 'demo1',
                        name: 'Progressive House Demo',
                        artist: 'Demo Artist',
                        type: 'major',
                        bpm: 128,
                        key: 'C Major',
                        duration: 240,
                        file: null
                    },
                    {
                        id: 'demo2',
                        name: 'Tropical House Demo',
                        artist: 'Demo Artist',
                        type: 'major',
                        bpm: 120,
                        key: 'G Major',
                        duration: 180
                    },
                    {
                        id: 'demo3',
                        name: 'Build-up Filler',
                        artist: 'Sample Pack',
                        type: 'filler',
                        bpm: 124,
                        key: 'C Major',
                        duration: 32
                    }
                ];
                
                sampleTracks.forEach(track => {
                    this.tracks.set(track.id, track);
                });
                
                this.renderTrackLibrary();
            }
            
            generateTrackId() {
                return 'track_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            }
            
            renderTrackLibrary() {
                const container = document.getElementById('trackLibrary');
                container.innerHTML = '';
                
                const filteredTracks = Array.from(this.tracks.values()).filter(track => 
                    this.selectedCategory === 'all' || track.type === this.selectedCategory
                );
                
                if (filteredTracks.length === 0) {
                    container.innerHTML = `
                        <div style="text-align: center; padding: 40px; color: rgba(255,255,255,0.5);">
                            <div style="font-size: 2em; margin-bottom: 10px;">üéµ</div>
                            <div>No ${this.selectedCategory === 'all' ? '' : this.selectedCategory} tracks found</div>
                            <div style="font-size: 0.8em; margin-top: 10px;">Drop audio files to get started!</div>
                        </div>
                    `;
                    return;
                }
                
                filteredTracks.forEach(track => {
                    const trackElement = this.createTrackElement(track);
                    container.appendChild(trackElement);
                });
            }
            
            createTrackElement(track) {
                const element = document.createElement('div');
                element.className = 'track-item';
                element.draggable = true;
                element.dataset.trackId = track.id;
                
                element.innerHTML = `
                    <div class="track-type ${track.type}">${track.type.toUpperCase()}</div>
                    <div class="track-info">
                        <div class="track-title">${track.name}</div>
                        <div class="track-details">
                            <span>${track.artist}</span>
                            <span>${track.bpm > 0 ? track.bpm + ' BPM' : 'Variable'}</span>
                        </div>
                        <div class="track-details">
                            <span>${track.key}</span>
                            <span>${this.formatDuration(track.duration)}</span>
                        </div>
                    </div>
                `;
                
                element.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('text/plain', track.id);
                    element.classList.add('dragging');
                });
                
                element.addEventListener('dragend', () => {
                    element.classList.remove('dragging');
                });
                
                element.addEventListener('dblclick', () => {
                    if (track.audioBuffer) {
                        this.playTrack(track);
                    }
                });
                
                return element;
            }
            
            addToChain(track) {
                const chainTrack = {
                    ...track,
                    chainId: `chain_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    startTime: this.calculateChainDuration(),
                    effects: [],
                    transitionType: 'crossfade',
                    volume: 1.0
                };
                
                this.chain.push(chainTrack);
                this.renderChain();
                this.updateStats();
                this.renderTimeline();
                this.showNotification(`Added "${track.name}" to chain`, 'success');
            }
            
            renderChain() {
                const container = document.getElementById('chainBuilder');
                
                // Clear existing content except drop zone
                const chainTracks = container.querySelectorAll('.chain-track');
                chainTracks.forEach(track => track.remove());
                
                if (this.chain.length === 0) {
                    document.getElementById('dropZone').style.display = 'flex';
                    return;
                }
                
                document.getElementById('dropZone').style.display = 'none';
                
                this.chain.forEach((track, index) => {
                    const trackElement = this.createChainTrackElement(track, index);
                    container.appendChild(trackElement);
                });
            }
            
            createChainTrackElement(track, index) {
                const element = document.createElement('div');
                element.className = 'chain-track';
                element.dataset.chainId = track.chainId;
                
                element.innerHTML = `
                    <div class="track-header">
                        <div class="track-name">${track.name}</div>
                        <div class="track-controls">
                            <button class="control-btn" onclick="app.playTrack(app.tracks.get('${track.id}'))">‚ñ∂Ô∏è Play</button>
                            <button class="control-btn" onclick="app.editTrack('${track.chainId}')">‚úèÔ∏è Edit</button>
                            <button class="control-btn" onclick="app.removeFromChain('${track.chainId}')">üóëÔ∏è Remove</button>
                        </div>
                    </div>
                    
                    <div class="waveform-container">
                        <canvas class="waveform-canvas" id="waveform_${track.chainId}"></canvas>
                    </div>
                    
                    <div class="spectogram-container">
                        <canvas class="spectogram-canvas" id="spectogram_${track.chainId}"></canvas>
                    </div>
                    
                    <div class="transition-controls">
                        <label>Transition:</label>
                        <select class="transition-select" onchange="app.updateTransition('${track.chainId}', this.value)">
                            <option value="crossfade" ${track.transitionType === 'crossfade' ? 'selected' : ''}>Crossfade</option>
                            <option value="cut" ${track.transitionType === 'cut' ? 'selected' : ''}>Hard Cut</option>
                            <option value="echo" ${track.transitionType === 'echo' ? 'selected' : ''}>Echo Fade</option>
                            <option value="filter" ${track.transitionType === 'filter' ? 'selected' : ''}>Filter Sweep</option>
                            <option value="reverse" ${track.transitionType === 'reverse' ? 'selected' : ''}>Reverse</option>
                        </select>
                        <span>Duration: ${this.formatDuration(track.duration)}</span>
                        <span>BPM: ${track.bpm}</span>
                        <span>Key: ${track.key}</span>
                    </div>
                    
                    ${index < this.chain.length - 1 ? 
                        `<div class="transition-arrow" onclick="app.editTransition(${index})">üîÑ</div>` : 
                        ''
                    }
                `;
                
                element.addEventListener('click', () => {
                    this.selectTrack(track.chainId);
                });
                
                // Render visualizations after DOM insertion
                setTimeout(() => {
                    this.renderWaveform(track);
                    this.renderSpectrogram(track);
                }, 10);
                
                return element;
            }
            
            renderWaveform(track) {
                const canvas = document.getElementById(`waveform_${track.chainId}`);
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                const rect = canvas.getBoundingClientRect();
                canvas.width = rect.width * window.devicePixelRatio;
                canvas.height = rect.height * window.devicePixelRatio;
                ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
                
                const width = rect.width;
                const height = rect.height;
                
                // Clear canvas
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, width, height);
                
                // Use real audio data if available
                if (track.audioBuffer) {
                    const channelData = track.audioBuffer.getChannelData(0);
                    const samples = Math.min(width, 2000); // Downsample for performance
                    const step = Math.floor(channelData.length / samples);
                    
                    ctx.strokeStyle = '#00ff9d';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    
                    for (let i = 0; i < samples; i++) {
                        const x = (i / samples) * width;
                        const sample = channelData[i * step] || 0;
                        const y = height / 2 + (sample * height / 2 * 0.8);
                        
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    
                    ctx.stroke();
                } else {
                    // Generate demo waveform
                    this.renderDemoWaveform(ctx, width, height);
                }
                
                // Add beat markers
                if (track.bpm > 0) {
                    ctx.fillStyle = '#667eea';
                    const beatsPerSecond = track.bpm / 60;
                    const totalBeats = Math.floor(track.duration * beatsPerSecond);
                    
                    for (let beat = 0; beat < totalBeats; beat++) {
                        const x = (beat / totalBeats) * width;
                        ctx.fillRect(x, height - 6, 2, 6);
                    }
                }
            }
            
            renderDemoWaveform(ctx, width, height) {
                const samples = 200;
                ctx.strokeStyle = '#00ff9d';
                ctx.lineWidth = 1;
                ctx.beginPath();
                
                for (let i = 0; i < samples; i++) {
                    const t = i / samples;
                    let amplitude = Math.sin(t * Math.PI * 2 * 4) * 0.5;
                    amplitude += Math.sin(t * Math.PI * 2 * 16) * 0.3;
                    amplitude += (Math.random() - 0.5) * 0.1;
                    amplitude *= (0.5 + Math.sin(t * Math.PI * 2) * 0.5);
                    
                    const x = (i / samples) * width;
                    const y = height / 2 + (amplitude * height / 2 * 0.8);
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                ctx.stroke();
            }
            
            renderSpectrogram(track) {
                const canvas = document.getElementById(`spectogram_${track.chainId}`);
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                const rect = canvas.getBoundingClientRect();
                canvas.width = rect.width * window.devicePixelRatio;
                canvas.height = rect.height * window.devicePixelRatio;
                ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
                
                const width = rect.width;
                const height = rect.height;
                
                // Use real spectrogram data if available
                if (track.analysis && track.analysis.spectrograms) {
                    this.renderRealSpectrogram(ctx, track.analysis.spectrograms, width, height);
                } else {
                    this.renderDemoSpectrogram(ctx, width, height);
                }
            }
            
            renderRealSpectrogram(ctx, spectrograms, width, height) {
                const timeSteps = Math.min(spectrograms.length, width);
                const freqBins = spectrograms[0] ? Math.min(spectrograms[0].length, height) : height;
                
                const stepX = width / timeSteps;
                const stepY = height / freqBins;
                
                for (let t = 0; t < timeSteps; t++) {
                    const spectrogram = spectrograms[Math.floor(t * spectrograms.length / timeSteps)];
                    if (!spectrogram) continue;
                    
                    for (let f = 0; f < freqBins; f++) {
                        const amplitude = spectrogram[Math.floor(f * spectrogram.length / freqBins)] || 0;
                        const normalizedAmp = Math.min(1, amplitude / 100); // Normalize
                        
                        // Color mapping: blue (low) to red (high)
                        let r, g, b;
                        if (normalizedAmp < 0.5) {
                            r = 0;
                            g = Math.floor(normalizedAmp * 2 * 255);
                            b = 255;
                        } else {
                            r = Math.floor((normalizedAmp - 0.5) * 2 * 255);
                            g = 255 - Math.floor((normalizedAmp - 0.5) * 2 * 255);
                            b = 0;
                        }
                        
                        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                        ctx.fillRect(
                            t * stepX, 
                            height - (f + 1) * stepY, 
                            Math.ceil(stepX), 
                            Math.ceil(stepY)
                        );
                    }
                }
            }
            
            renderDemoSpectrogram(ctx, width, height) {
                const timeSteps = 100;
                const freqBins = 40;
                
                const stepX = width / timeSteps;
                const stepY = height / freqBins;
                
                for (let t = 0; t < timeSteps; t++) {
                    for (let f = 0; f < freqBins; f++) {
                        let amplitude = Math.random() * 0.3;
                        
                        // Add some structure
                        if (f < 10) amplitude += Math.sin(t * 0.1) * 0.4; // Bass
                        if (f > 20 && f < 30) amplitude += Math.sin(t * 0.05) * 0.3; // Mids
                        if (f > 30) amplitude += Math.random() * 0.2; // Highs
                        
                        amplitude = Math.max(0, Math.min(1, amplitude));
                        
                        // Color mapping
                        let r, g, b;
                        if (amplitude < 0.5) {
                            r = 0;
                            g = Math.floor(amplitude * 2 * 255);
                            b = 255;
                        } else {
                            r = Math.floor((amplitude - 0.5) * 2 * 255);
                            g = 255 - Math.floor((amplitude - 0.5) * 2 * 255);
                            b = 0;
                        }
                        
                        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                        ctx.fillRect(
                            t * stepX, 
                            height - (f + 1) * stepY, 
                            Math.ceil(stepX), 
                            Math.ceil(stepY)
                        );
                    }
                }
            }
            
            renderTimeline() {
                const canvas = document.getElementById('timelineCanvas');
                const ctx = canvas.getContext('2d');
                const rect = canvas.getBoundingClientRect();
                
                canvas.width = rect.width * window.devicePixelRatio;
                canvas.height = rect.height * window.devicePixelRatio;
                ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
                
                const width = rect.width;
                const height = rect.height;
                
                // Clear canvas
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, width, height);
                
                if (this.chain.length === 0) return;
                
                const totalDuration = this.calculateChainDuration();
                let currentTime = 0;
                
                this.chain.forEach((track, index) => {
                    const startX = (currentTime / totalDuration) * width;
                    const trackWidth = (track.duration / totalDuration) * width;
                    
                    // Track color based on type
                    const colors = {
                        major: '#667eea',
                        filler: '#4ecdc4',
                        sample: '#feca57',
                        effect: '#a29bfe'
                    };
                    
                    ctx.fillStyle = colors[track.type] || '#666';
                    ctx.fillRect(startX, 30, trackWidth, height - 60);
                    
                    // Track name
                    ctx.fillStyle = '#fff';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'left';
                    
                    if (trackWidth > 60) {
                        const text = track.name.length > 20 ? track.name.substring(0, 17) + '...' : track.name;
                        ctx.fillText(text, startX + 8, height / 2 + 4);
                    }
                    
                    // Transition markers
                    if (index < this.chain.length - 1) {
                        ctx.fillStyle = '#ff6b6b';
                        ctx.fillRect(startX + trackWidth - 3, 0, 6, height);
                    }
                    
                    currentTime += track.duration;
                });
                
                // Playback position
                if (this.isPlaying) {
                    const playheadX = (this.playbackTime / totalDuration) * width;
                    ctx.strokeStyle = '#00ff9d';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(playheadX, 0);
                    ctx.lineTo(playheadX, height);
                    ctx.stroke();
                }
            }
            
            async playTrack(track) {
                if (!track.audioBuffer) {
                    this.showNotification('Track not loaded with audio data', 'error');
                    return;
                }
                
                // Stop current playback
                if (this.currentSource) {
                    this.currentSource.stop();
                }
                
                try {
                    // Create new audio source
                    this.currentSource = this.audioContext.createBufferSource();
                    this.currentSource.buffer = track.audioBuffer;
                    this.currentSource.connect(this.mainGain);
                    
                    // Start playback
                    this.currentSource.start();
                    this.startTime = this.audioContext.currentTime;
                    this.isPlaying = true;
                    
                    // Update UI
                    document.querySelectorAll('.chain-track').forEach(el => el.classList.remove('playing'));
                    const trackElement = document.querySelector(`[data-chain-id="${track.chainId}"]`);
                    if (trackElement) {
                        trackElement.classList.add('playing');
                    }
                    
                    this.showNotification(`Playing: ${track.name}`, 'success');
                    
                    // Handle playback end
                    this.currentSource.onended = () => {
                        this.isPlaying = false;
                        document.querySelectorAll('.chain-track').forEach(el => el.classList.remove('playing'));
                    };
                    
                } catch (error) {
                    console.error('Error playing track:', error);
                    this.showNotification('Error playing track', 'error');
                }
            }
            
            selectTrack(chainId) {
                document.querySelectorAll('.chain-track').forEach(track => {
                    track.classList.remove('selected');
                });
                
                const trackElement = document.querySelector(`[data-chain-id="${chainId}"]`);
                if (trackElement) {
                    trackElement.classList.add('selected');
                    this.currentTrack = this.chain.find(track => track.chainId === chainId);
                }
            }
            
            calculateChainDuration() {
                return this.chain.reduce((total, track) => total + track.duration, 0);
            }
            
            updateStats() {
                document.getElementById('chainLength').textContent = this.chain.length;
                
                const totalDuration = this.calculateChainDuration();
                document.getElementById('totalDuration').textContent = this.formatDuration(totalDuration);
                
                const bpmTracks = this.chain.filter(track => track.bpm > 0);
                const avgBPM = bpmTracks.length > 0 ? 
                    Math.round(bpmTracks.reduce((sum, track) => sum + track.bpm, 0) / bpmTracks.length) : 0;
                document.getElementById('avgBPM').textContent = avgBPM;
                
                const compatibility = this.calculateChainCompatibility();
                document.getElementById('compatibility').textContent = Math.round(compatibility * 100) + '%';
            }
            
            calculateChainCompatibility() {
                if (this.chain.length < 2) return 1;
                
                let totalCompatibility = 0;
                let comparisons = 0;
                
                for (let i = 0; i < this.chain.length - 1; i++) {
                    const track1 = this.chain[i];
                    const track2 = this.chain[i + 1];
                    
                    // BPM compatibility
                    const bpmDiff = Math.abs(track1.bpm - track2.bpm);
                    const bpmCompatibility = Math.max(0, 1 - bpmDiff / 20);
                    
                    // Key compatibility (simplified)
                    const keyCompatibility = track1.key === track2.key ? 1 : 0.7;
                    
                    totalCompatibility += (bpmCompatibility + keyCompatibility) / 2;
                    comparisons++;
                }
                
                return comparisons > 0 ? totalCompatibility / comparisons : 1;
            }
            
            formatDuration(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            }
            
            startVisualization() {
                const animate = () => {
                    this.updateFrequencyVisualization();
                    if (this.isPlaying) {
                        this.updatePlaybackTime();
                        this.renderTimeline();
                    }
                    requestAnimationFrame(animate);
                };
                animate();
            }
            
            updateFrequencyVisualization() {
                const canvas = document.getElementById('frequencyCanvas');
                const ctx = canvas.getContext('2d');
                const rect = canvas.getBoundingClientRect();
                
                canvas.width = rect.width * window.devicePixelRatio;
                canvas.height = rect.height * window.devicePixelRatio;
                ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
                
                const width = rect.width;
                const height = rect.height;
                
                // Clear canvas
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, width, height);
                
                if (this.analyzer) {
                    const bufferLength = this.analyzer.frequencyBinCount;
                    const dataArray = new Uint8Array(bufferLength);
                    this.analyzer.getByteFrequencyData(dataArray);
                    
                    const barCount = 32;
                    const barWidth = width / barCount;
                    
                    for (let i = 0; i < barCount; i++) {
                        const value = dataArray[Math.floor(i * bufferLength / barCount)];
                        const barHeight = (value / 255) * height * 0.8;
                        const hue = (i / barCount) * 120 + 180; // Blue to cyan
                        
                        ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                        ctx.fillRect(i * barWidth, height - barHeight, barWidth - 2, barHeight);
                    }
                }
            }
            
            updatePlaybackTime() {
                if (this.isPlaying && this.startTime) {
                    this.playbackTime = this.audioContext.currentTime - this.startTime;
                    this.updateTimeDisplay();
                }
            }
            
            updateTimeDisplay() {
                const current = this.formatDuration(this.playbackTime);
                const total = this.formatDuration(this.calculateChainDuration());
                document.getElementById('timeDisplay').textContent = `${current} / ${total}`;
            }
            
            showNotification(message, type = 'info') {
                const notification = document.getElementById('notification');
                notification.textContent = message;
                notification.className = `notification ${type}`;
                notification.classList.add('show');
                
                setTimeout(() => {
                    notification.classList.remove('show');
                }, 3000);
            }
            
            // API Methods
            removeFromChain(chainId) {
                this.chain = this.chain.filter(track => track.chainId !== chainId);
                this.renderChain();
                this.updateStats();
                this.renderTimeline();
                this.showNotification('Track removed from chain', 'success');
            }
            
            editTrack(chainId) {
                const track = this.chain.find(t => t.chainId === chainId);
                if (track) {
                    this.showNotification(`Editing: ${track.name}`, 'info');
                }
            }
            
            updateTransition(chainId, transitionType) {
                const track = this.chain.find(t => t.chainId === chainId);
                if (track) {
                    track.transitionType = transitionType;
                    this.showNotification(`Updated transition: ${transitionType}`, 'success');
                }
            }
            
            editTransition(index) {
                if (index < this.chain.length - 1) {
                    const track1 = this.chain[index];
                    const track2 = this.chain[index + 1];
                    this.showNotification(`Editing transition: ${track1.name} ‚Üí ${track2.name}`, 'info');
                }
            }
        }
        
        // Global app instance
        const app = new EDMChainBuilderPro();
        
        // Global functions for UI
        function showFileDialog() {
            document.getElementById('fileInput').click();
        }
        
        async function handleFileUpload(event) {
            const files = Array.from(event.target.files);
            if (files.length > 0) {
                await app.processUploadedFiles(files);
            }
        }
        
        function toggleEffect(element, effectName) {
            element.classList.toggle('active');
            
            if (app.activeEffects.has(effectName)) {
                app.activeEffects.delete(effectName);
            } else {
                app.activeEffects.add(effectName);
            }
            
            app.showNotification(`${effectName} ${element.classList.contains('active') ? 'enabled' : 'disabled'}`, 'info');
        }
        
        function togglePlayback() {
            const playBtn = document.getElementById('playBtn');
            
            if (app.isPlaying) {
                // Stop playback
                if (app.currentSource) {
                    app.currentSource.stop();
                }
                app.isPlaying = false;
                playBtn.innerHTML = '‚ñ∂Ô∏è Play Chain';
                playBtn.classList.remove('playing');
            } else {
                // Start chain playback
                if (app.chain.length > 0) {
                    app.playTrack(app.chain[0]);
                    playBtn.innerHTML = '‚è∏Ô∏è Pause';
                    playBtn.classList.add('playing');
                } else {
                    app.showNotification('Add tracks to the chain first!', 'error');
                }
            }
        }
        
        function stopPlayback() {
            if (app.currentSource) {
                app.currentSource.stop();
            }
            app.isPlaying = false;
            app.playbackTime = 0;
            const playBtn = document.getElementById('playBtn');
            playBtn.innerHTML = '‚ñ∂Ô∏è Play Chain';
            playBtn.classList.remove('playing');
            document.querySelectorAll('.chain-track').forEach(el => el.classList.remove('playing'));
            app.updateTimeDisplay();
        }
        
        function previewTransition() {
            if (app.currentTrack) {
                app.showNotification(`Previewing transition for: ${app.currentTrack.name}`, 'info');
            } else {
                app.showNotification('Select a track to preview its transition', 'error');
            }
        }
        
        function analyzeChain() {
            if (app.chain.length === 0) {
                app.showNotification('Add tracks to the chain first!', 'error');
                return;
            }
            
            const compatibility = app.calculateChainCompatibility();
            const analysis = `Chain Analysis:\n\n` +
                `‚Ä¢ Tracks: ${app.chain.length}\n` +
                `‚Ä¢ Duration: ${app.formatDuration(app.calculateChainDuration())}\n` +
                `‚Ä¢ Compatibility: ${Math.round(compatibility * 100)}%\n` +
                `‚Ä¢ Effects: ${app.activeEffects.size}\n\n` +
                `${compatibility > 0.8 ? '‚úÖ Excellent flow!' : '‚ö†Ô∏è Consider BPM/key adjustments'}`;
            
            alert(analysis);
        }
        
        function autoGenerateTransitions() {
            if (app.chain.length < 2) {
                app.showNotification('Need at least 2 tracks for transitions!', 'error');
                return;
            }
            
            // Auto-generate logic
            app.chain.forEach((track, index) => {
                if (index < app.chain.length - 1) {
                    const nextTrack = app.chain[index + 1];
                    
                    if (Math.abs(track.bpm - nextTrack.bpm) > 10) {
                        track.transitionType = 'filter';
                    } else if (track.key !== nextTrack.key) {
                        track.transitionType = 'echo';
                    } else {
                        track.transitionType = 'crossfade';
                    }
                }
            });
            
            app.renderChain();
            app.showNotification('Auto-generated transitions!', 'success');
        }
        
        function exportChain() {
            if (app.chain.length === 0) {
                app.showNotification('No chain to export!', 'error');
                return;
            }
            
            const exportData = {
                chain: app.chain.map(track => ({
                    name: track.name,
                    artist: track.artist,
                    type: track.type,
                    bpm: track.bpm,
                    key: track.key,
                    duration: track.duration,
                    transitionType: track.transitionType,
                    startTime: track.startTime
                })),
                effects: Array.from(app.activeEffects),
                metadata: {
                    totalDuration: app.calculateChainDuration(),
                    compatibility: app.calculateChainCompatibility(),
                    exported: new Date().toISOString()
                }
            };
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'edm-chain-export.json';
            a.click();
            URL.revokeObjectURL(url);
            
            app.showNotification('Chain exported successfully!', 'success');
        }
        
        function exportProject() {
            app.showNotification('Project export would save all tracks and settings', 'info');
        }
        
        function renderMix() {
            if (app.chain.length === 0) {
                app.showNotification('Add tracks to render!', 'error');
                return;
            }
            
            app.showNotification('Mix rendering would create seamless audio output', 'info');
        }
        
        function showHelp() {
            const helpText = `EDM Chain Builder Pro - Quick Help

üéµ Getting Started:
‚Ä¢ Drag & drop audio files (MP3, WAV, OGG)
‚Ä¢ Files are automatically analyzed and categorized
‚Ä¢ Drag tracks from library to chain builder

üéõÔ∏è Track Types:
‚Ä¢ Major: Full songs (3+ minutes)
‚Ä¢ Filler: Transition segments (30-90 seconds)  
‚Ä¢ Sample: Short loops (<15 seconds)
‚Ä¢ Effect: Sound effects and atmospheres

üîÑ Transitions:
‚Ä¢ Crossfade: Smooth volume transition
‚Ä¢ Filter: Frequency sweep transition
‚Ä¢ Echo: Echo fade effect
‚Ä¢ Cut: Hard cut between tracks
‚Ä¢ Reverse: Reverse effect transition

‚ö° Features:
‚Ä¢ Real-time frequency analysis
‚Ä¢ Automatic BPM/key detection
‚Ä¢ Harmonic compatibility scoring
‚Ä¢ Chain optimization suggestions
‚Ä¢ Professional export formats

üéπ Playback:
‚Ä¢ Double-click tracks to preview
‚Ä¢ Use transport controls for chain playback
‚Ä¢ Real-time visualization during playback`;
            
            alert(helpText);
        }
    </script>
</body>
</html>